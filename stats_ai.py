# -*- coding: utf-8 -*-
"""Stats_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ieODzPNiBmI79oce4E0oZ55DbM6mK_Qq
"""



# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import math
# import matplotlib.pyplot as plt
# import google.generativeai as genai
# import ast
# 
# # Set up Gemini API key
import streamlit as st
genai.configure(api_key=st.secrets["GEMINI_API_KEY"])
# 
# # -----------------------------
# # Distribution Functions
# # -----------------------------
# def binomial_dist(n, p, k):
#     return math.comb(n, k) * (p ** k) * ((1 - p) ** (n - k))
# 
# def geometric_dist(k, p):
#     return (1 - p) ** (k - 1) * p
# 
# def poisson_dist(lamda, k):
#     return (lamda ** k) * math.exp(-lamda) / math.factorial(k)
# 
# def hypergeom_dist(N, K_big, n, k):
#     return (math.comb(K_big, k) * math.comb(N - K_big, n - k)) / math.comb(N, n)
# 
# def uniform_dist(a, b, x):
#     if a is None or b is None or x is None:
#         raise ValueError("We couldn‚Äôt find values for a, b, or x. Please clarify your question.")
#     if a <= x <= b:
#         return 1 / (b - a + 1)
#     else:
#         return 0
# 
# # -----------------------------
# # Plotting Functions
# # -----------------------------
# def plot_binomial(n, p):
#     x = list(range(n + 1))
#     y = [binomial_dist(n, p, k) for k in x]
#     plt.clf()
#     plt.bar(x, y)
#     plt.title(f"Binomial Distribution (n={n}, p={p})")
#     plt.xlabel("Successes")
#     plt.ylabel("Probability")
#     st.pyplot(plt)
# 
# def plot_geometric(k, p):
#     x = list(range(1, k + 6))
#     y = [geometric_dist(i, p) for i in x]
#     plt.clf()
#     plt.bar(x, y)
#     plt.title(f"Geometric Distribution (p={p})")
#     plt.xlabel("Trial")
#     plt.ylabel("Probability")
#     st.pyplot(plt)
# 
# def plot_poisson(lamda, k):
#     x = list(range(0, k + 6))
#     y = [poisson_dist(lamda, i) for i in x]
#     plt.clf()
#     plt.bar(x, y)
#     plt.title(f"Poisson Distribution (Œª={lamda})")
#     plt.xlabel("Events")
#     plt.ylabel("Probability")
#     st.pyplot(plt)
# 
# def plot_hypergeom(N, K_big, n):
#     x = list(range(max(0, n - (N - K_big)), min(K_big, n) + 1))
#     y = [hypergeom_dist(N, K_big, n, k) for k in x]
#     plt.clf()
#     plt.bar(x, y)
#     plt.title(f"Hypergeometric (N={N}, K={K_big}, n={n})")
#     plt.xlabel("Successes (k)")
#     plt.ylabel("Probability")
#     st.pyplot(plt)
# 
# def plot_uniform(a, b):
#     if a is None or b is None:
#         return
#     x = list(range(a, b + 1))
#     y = [uniform_dist(a, b, i) for i in x]
#     plt.clf()
#     plt.bar(x, y)
#     plt.title(f"Uniform Distribution [{a}, {b}]")
#     plt.xlabel("x")
#     plt.ylabel("Probability")
#     st.pyplot(plt)
# 
# # -----------------------------
# # LLM Parsing Function
# # -----------------------------
# def llm_parse_gemini(question):
#     prompt = f"""
# You are a Python assistant that calculates probabilities using binomial, geometric, Poisson, uniform, or hypergeometric distributions.
# 
# Use only these functions:
# - binomial_dist(n, p, k)
# - geometric_dist(k, p)
# - poisson_dist(lamda, k)
# - hypergeom_dist(N, K_big, n, k)
# - uniform_dist(a, b, x)
# 
# Only use variables: n, k, p, lamda, N, K_big, a, b, x
# Return output as a Python dictionary on ONE LINE like:
# {{"distribution": "binomial", "code": "prob = binomial_dist(n, p, k)", "n": 10, "p": 0.3, "k": 4, "lamda": None, "N": None, "K_big": None, "a": None, "b": None, "x": None}}
# 
# DO NOT include explanation, markdown, or newlines.
# Question: \"\"\"{question}\"\"\"
# """
#     model = genai.GenerativeModel("models/gemini-1.5-flash")
#     response = model.generate_content(prompt)
#     raw_text = response.text.strip().replace("null", "None")
# 
#     try:
#         parsed = ast.literal_eval(raw_text)
#     except Exception as e:
#         raise ValueError(f"Failed to parse response: {raw_text}\nError: {e}")
# 
#     return parsed
# 
# # -----------------------------
# # Streamlit App UI
# # -----------------------------
# st.set_page_config(page_title="üìä Stats AI ‚Äì Gemini-powered Probability App", page_icon="üìä", layout="centered")
# 
# with st.sidebar:
#     st.title("üìö How to Use")
#     st.markdown("""
#     1. Ask any probability question.
#     2. Supported distributions:
#        - Binomial
#        - Geometric
#        - Poisson
#        - Uniform
#        - Hypergeometric
#     3. We'll show the:
#        - üìà Plot
#        - ‚úÖ Probability
#        - üí° Distribution Explanation
#     """)
#     st.markdown("---")
#     st.caption("Built with ‚ù§Ô∏è using Gemini & Streamlit")
# 
# st.markdown("<h1 style='text-align: center;'>üìä Stats AI</h1>", unsafe_allow_html=True)
# st.markdown("<h4 style='text-align: center;'>ü§ñ Powered by Google Gemini ¬∑ Made for Students</h4>", unsafe_allow_html=True)
# st.markdown("---")
# 
# with st.expander("üí¨ Example Questions"):
#     st.code("What‚Äôs the probability of 4 successes in 10 trials with 0.3 chance?")
#     st.code("What's the probability the first success is on trial 5 with 0.1 chance?")
#     st.code("What‚Äôs the probability of fewer than 2 events when Œª = 3?")
#     st.code("What‚Äôs the probability that x = 5 when uniformly picked between a = 3 and b = 7?")
# 
# question = st.text_input("üìù Ask your probability question here:")
# decimals = st.slider("üî¢ Round the result to:", 0, 6, 3)
# 
# if question:
#     try:
#         with st.spinner("ü§î Thinking with Gemini..."):
#             parsed = llm_parse_gemini(question)
# 
#         code = parsed["code"]
#         local_vars = {
#             "n": parsed.get("n"),
#             "k": parsed.get("k"),
#             "p": parsed.get("p"),
#             "lamda": parsed.get("lamda"),
#             "N": parsed.get("N"),
#             "K_big": parsed.get("K_big"),
#             "a": parsed.get("a"),
#             "b": parsed.get("b"),
#             "x": parsed.get("x"),
#             "binomial_dist": binomial_dist,
#             "geometric_dist": geometric_dist,
#             "poisson_dist": poisson_dist,
#             "hypergeom_dist": hypergeom_dist,
#             "uniform_dist": uniform_dist,
#         }
# 
#         exec(code, {}, local_vars)
#         prob = local_vars["prob"]
#         st.success(f"‚úÖ **Probability = {round(prob, decimals)}**")
# 
#         d = parsed["distribution"]
#         st.subheader("üìà Visualize Distribution")
# 
#         distribution_facts = {
#             "binomial": {
#                 "desc": "Models the number of successes in a fixed number of independent trials...",
#                 "fact": "üé≤ Fun Fact: The binomial distribution underlies the logic of flipping coins!",
#                 "explanation": "The binomial distribution helps you find the probability of getting a certain number of 'successes' (like heads in a coin toss) in a fixed number of tries. Each trial is independent and has only two outcomes‚Äîsuccess or failure. This is great for yes/no experiments like medical tests, multiple-choice questions, or quality checks."
#             },
#             "geometric": {
#                 "desc": "Describes the probability of the first success occurring on a specific trial.",
#                 "fact": "üéØ Fun Fact: It's memoryless‚Äîpast failures don't change future probabilities!",
#                 "explanation": "The geometric distribution is used when you're waiting for your first success. It answers questions like, 'How many times do I need to try before I succeed?' It's useful in real life for things like troubleshooting a machine or finding a matching key‚Äîeach attempt is independent, and the chances stay the same every time."
#             },
#             "poisson": {
#                 "desc": "Estimates the probability of a number of events occurring within a fixed interval of time or space.",
#                 "fact": "üìà Fun Fact: It was first used to model horse-kick deaths in the Prussian army!",
#                 "explanation": "The Poisson distribution is used when you want to count how often an event happens in a specific time or space‚Äîlike how many people enter a store per hour or how many emails you get per day. It's great when the event is rare but can happen any number of times, and each event is independent of the last."
#             },
#             "hypergeometric": {
#                 "desc": "Used when sampling without replacement‚Äîlike drawing cards from a deck without putting them back.",
#                 "fact": "üÉè Fun Fact: Unlike binomial, the probability changes each time because the population shrinks!",
#                 "explanation": "The hypergeometric distribution comes into play when you're selecting items without putting them back‚Äîlike picking raffle tickets or selecting defective items in a batch. Unlike binomial, the chances change after each pick because the total pool is shrinking. It's perfect for modeling real-world situations where repetition isn't allowed."
#             },
#             "uniform": {
#                 "desc": "Every outcome in the range [a, b] has an equal chance of occurring.",
#                 "fact": "üé≤ Fun Fact: A fair dice roll is the perfect example of a uniform distribution!",
#                 "explanation": "The discrete uniform distribution is the simplest of all‚Äîevery outcome is equally likely. It's great for modeling situations like rolling a fair die or picking a number from a hat. If there's no bias and everything is equally possible, this is your go-to model."
#             }
#         }
# 
#         if d == "binomial":
#             plot_binomial(local_vars["n"], local_vars["p"])
#         elif d == "geometric":
#             plot_geometric(local_vars["k"], local_vars["p"])
#         elif d == "poisson":
#             plot_poisson(local_vars["lamda"], local_vars["k"])
#         elif d == "hypergeometric":
#             plot_hypergeom(local_vars["N"], local_vars["K_big"], local_vars["n"])
#         elif d == "uniform":
#             plot_uniform(local_vars["a"], local_vars["b"])
# 
#         if d in distribution_facts:
#             st.info(f"**{d.capitalize()} Distribution**: {distribution_facts[d]['desc']}")
#             st.caption(distribution_facts[d]['fact'])
#             st.write(distribution_facts[d]["explanation"])
# 
#     except Exception as e:
#         st.warning("‚ö†Ô∏è Could not parse question. Try rephrasing.")
#         st.exception(e)
#


from pyngrok import conf, ngrok
conf.get_default().auth_token = st.secrets["NGROK_AUTH_TOKEN"]


from pyngrok import ngrok
public_url = ngrok.connect(8501)
print("üåê Public URL:", public_url)
